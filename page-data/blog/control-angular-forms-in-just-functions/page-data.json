{"componentChunkName":"component---src-templates-post-page-template-js","path":"/blog/control-angular-forms-in-just-functions/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Control angular forms in just functions ðŸ”¥\",\n  \"date\": \"2020-06-17T00:00:00.000Z\",\n  \"published\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Forms are an important concept to be covered and controlled in the client-side development... in the previous article, I talked about forms in angular and how to manage them easily with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rxjs\"), \".\"), mdx(\"p\", null, \"{% post \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://dev.to/muhammedmoussa/hack-angular-forms-with-rxjs-4he7\"\n  }), \"https://dev.to/muhammedmoussa/hack-angular-forms-with-rxjs-4he7\"), \" %}\"), mdx(\"h1\", null, \"Idea:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"keep it simple is a concept, we will use only angular two-way data binding connected with only functions and component props in a functional way. no more template-driven, reactive forms or even observable forms :D \")), mdx(\"mark\", null, \"Note:\"), \" this pattern can be useful in small static forms.\", mdx(\"p\", null, \"we will be going with pseudocode for HTML and component coverage and the full code with demo will be included. let's start!\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://media.giphy.com/media/l1J9xV815LOOTUju0/giphy.gif\",\n    \"alt\": \"GIF\"\n  }))), mdx(\"h1\", null, \"Component Goal:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"let's assume that we have a user form component as pice of our app and we planned to reuse it so it will be declarative enough and prevent its noise from parent components will render. here are some props and functions our component will need.\")), mdx(\"h1\", null, \"Component Ui:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the form is simple to keep the view part only focusing on UI stuff and CSS styling, with just inputs and a piece of banana in the box \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[()]\"), \", with buttons eventually binding into the component class.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<div>\\n  <input [(ngModel)]=\\\"name\\\" type=\\\"text\\\">\\n  <input [(ngModel)]=\\\"active\\\" type=\\\"checkbox\\\">\\n  <button (click)=\\\"onSubmit()\\\">Save</button>\\n  <button (click)=\\\"onReset()\\\">Reset</button>\\n</div>\\n\")), mdx(\"p\", null, \"that's all that we need from our component view. no more logic noise clear or directives.\"), mdx(\"h1\", null, \"Functional part in component:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the place where the component view will dance, we need two main things only. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"variables\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"props\"), \" which will act as form controls, and functions that are will handle form actions like \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"submit\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reset\"), \".\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"export class UserFormComponent {\\n  // controls \\n  name = ''\\n  active = false\\n\\n  onSubmit() {\\n    // collecting component data before submit. \\n    const {name, age} = this\\n    const userData = {name, age}\\n\\n    console.log(userData)\\n  }\\n\\n  onReset() { \\n    // component is clear again.\\n    this.name = '';\\n    this.active = false\\n  }\\n}\\n\")), mdx(\"p\", null, \"and that's it we have a simple clean component that will act as a solid piece from our greater app!\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://media.giphy.com/media/26u4lOMA8JKSnL9Uk/giphy.gif\",\n    \"alt\": \"GIF\"\n  }))), mdx(\"h1\", null, \"Bonus:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"since we are building a solid re-usable component so we have to consider its communication channel with the other components. Yah. it needs to pass its data into the world and we can deal with that inside angular by event emitting via \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@Output()\"), \". actually, we almost need the form data when submitting the event but in some cases, we need to emit also reset events to the parent component for any reset stuff related to other components. let's implement both.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"export class UserFormComponent {\\n  @Output() submit = new EventEmitter<object>()\\n  @Output() reset = new EventEmitter<any>()\\n\\n  onSubmit() {\\n    // collecting component data before submit. \\n    const {name, age} = this\\n    const userData = {name, age}\\n\\n    console.log(userData)\\n    this.submit.emit(userData)\\n  }\\n\\n  onReset() {\\n    this.reset.emit()\\n  }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"another pro tip to validate our form before submit and again form logic will be inside it, not another place so let's validate before traveling to the parent component. in just function no more built-in or third-party validators.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"export class UserFormComponent {\\n  onSubmit() {\\n    // validating component data before submit.\\n    if(!this.isValid()) { return }\\n\\n    // ... submit code\\n  }\\n\\n  private isValid(): boolean {\\n    // just required name and active. you can go with your validation logic and add another else if blocks.\\n    const {name, active} = this\\n    if(name && active) {\\n      return true\\n    } else {\\n      return false\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"#Concolusion \\uD83D\\uDD90\\uFE0F#\\nwe discussed forms management tips for angular development by using built-in frameworks  Data binding and event emitters. in a functional way, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"BUT\"), \" this approach not Exclusive at angular think about it functional programming is heavily welcomed in javascript frameworks and the second part is a data binding is a behavior that another framework can offer like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"VueJs\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v-model\"), \" directive. and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState()\"), \" hook. so this pattern may be useful at any js framework not only angular.\"), mdx(\"p\", null, \"thought sharing is welcomed since all of that post is just a personal point of view through daily experience.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/muhammedMoussa/angular-forms-tips\"\n  }), \"Github Repo\"), \"\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://angular-forms-tips.netlify.app/\"\n  }), \"Live Demo\"), \"\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/muhammedmoussa\"\n  }), \"Find Me on Twitter\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Control angular forms in just functions ðŸ”¥","date":"2020 June 17th"}}},"pageContext":{"id":"a3a4f329-c058-5e07-9bb8-b2c67a43b242"}},"staticQueryHashes":["3159585216","717330468"]}